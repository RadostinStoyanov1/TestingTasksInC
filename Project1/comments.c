/* Задача 1: Основната функция приема стринг до 256 символа, като дължината му е макро константа. При броенето на символите се търси точно символът за малка буква ‘a’ (ASCII код 97), а главна буква ‘A’ не се взема под внимание (не е използвана char функцията tolower()), защото по условие не е зададено.

Задача 2: Принципа е същия като в задача 1, само че създадената функцията за броене на ‘a’ символите е void.

Задача 3: Отново се чете стринг до 256 символа от основната функция и се ползва функцията от задача 1, за да се определи колко символа ‘a’ ще се премахнат, и така може да се определи колко динамична памет ще е необходима за създаване на новия стринг, който няма да включва ‘a’ символи. Накрая новосъздадения стринг се копира в първоначалния стринг чрез strcpy().
	За четене на входящия низ въведен от потребителя в терминала не се използва fgets() функцията, защото с нея в прочетения стринг влиза и символа за нов ред (‘\n’) в края на масива. Този символ се появява след като потребителя въведе своя стринг в терминала и натисне “Enter”. 
 
Задача 4: Принципа е същия като в задача 3, само че се създава масив в динамичната памет с по-голям размер от този на първоначално прочетения стринг.

Задача 5: Върнатите символи от първоначалния низ,  са в обратен ред: например при вход “opel astra”, се връща низ “artsa”. Оставям го така, понеже не е уточнено как да се принтират последните 5 символа в заданието. Ако е необходимо може да се промени реда на принтиране.

Задача 6: За решението се използват два глобални масива – един от символи и друг от int-ове, които играят ролята на Мап. Всяка промяна в единия масив, се извършва и в другия масив, за да вървят заедно ключ от единия масив и стойност от другия масив. За сортиране на масивите се използва метод Bubble sort.
	Програмата работи само със стандартни (not extended) ASCII кодове. Вход на кирилица не се прочита. */
